#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Configuration
const RESPONSES_DIR = path.join(__dirname, '../FreeWaterTips.Utils/Responses');
const OUTPUT_FILE = path.join(__dirname, '../FreeWaterTips.ReactNative/src/types/api.ts');

// C# to TypeScript type mapping
const typeMapping = {
  'string': 'string',
  'String': 'string',
  'int': 'number',
  'Int32': 'number',
  'long': 'number',
  'Int64': 'number',
  'float': 'number',
  'double': 'number',
  'Double': 'number',
  'decimal': 'number',
  'Decimal': 'number',
  'bool': 'boolean',
  'Boolean': 'boolean',
  'DateTime': 'string', // ISO 8601 string
  'DateTimeOffset': 'string',
  'Guid': 'string',
  'object': 'any',
  'Object': 'any',
};

function mapCSharpTypeToTypeScript(csharpType) {
  // Remove nullable marker
  let type = csharpType.replace(/\?$/, '');
  const isNullable = csharpType.endsWith('?');
  
  // Handle arrays/lists
  const arrayMatch = type.match(/^(List|IEnumerable|ICollection|Array)<(.+)>$/);
  if (arrayMatch) {
    const innerType = mapCSharpTypeToTypeScript(arrayMatch[2]);
    return `${innerType}[]`;
  }
  
  // Handle dictionaries
  const dictMatch = type.match(/^(Dictionary|IDictionary)<(.+),\s*(.+)>$/);
  if (dictMatch) {
    const valueType = mapCSharpTypeToTypeScript(dictMatch[3]);
    return `Record<string, ${valueType}>`;
  }
  
  // Map primitive types
  const mappedType = typeMapping[type] || type;
  
  return isNullable ? `${mappedType} | null` : mappedType;
}

function parseCSharpClass(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath, '.cs');
  
  // Extract class name
  const classMatch = content.match(/public\s+class\s+(\w+)/);
  if (!classMatch) {
    console.warn(`Could not find class definition in ${fileName}`);
    return null;
  }
  
  const className = classMatch[1];
  const properties = [];
  
  // Extract properties (public properties with getters)
  const propertyRegex = /public\s+([\w<>,?\s]+)\s+(\w+)\s*{\s*(?:get;|get\s*[={])/g;
  let match;
  
  while ((match = propertyRegex.exec(content)) !== null) {
    const csharpType = match[1].trim();
    const propertyName = match[2];
    const tsType = mapCSharpTypeToTypeScript(csharpType);
    
    // Convert PascalCase to camelCase
    const tsPropertyName = propertyName.charAt(0).toLowerCase() + propertyName.slice(1);
    
    properties.push({
      name: tsPropertyName,
      type: tsType,
      originalName: propertyName
    });
  }
  
  return {
    className,
    properties
  };
}

function generateTypeScriptInterface(classInfo) {
  if (!classInfo || classInfo.properties.length === 0) {
    return '';
  }
  
  const { className, properties } = classInfo;
  let tsCode = `export interface ${className} {\n`;
  
  properties.forEach(prop => {
    tsCode += `  ${prop.name}: ${prop.type};\n`;
  });
  
  tsCode += '}\n';
  
  return tsCode;
}

function generateAllTypes() {
  console.log('üîÑ Generating TypeScript types from C# Response classes...');
  console.log(`üìÇ Source: ${RESPONSES_DIR}`);
  console.log(`üìù Output: ${OUTPUT_FILE}`);
  
  if (!fs.existsSync(RESPONSES_DIR)) {
    console.error(`‚ùå Error: Responses directory not found at ${RESPONSES_DIR}`);
    process.exit(1);
  }
  
  // Read all .cs files from Responses directory
  const files = fs.readdirSync(RESPONSES_DIR)
    .filter(file => file.endsWith('.cs'))
    .sort();
  
  if (files.length === 0) {
    console.warn('‚ö†Ô∏è  No C# files found in Responses directory');
    return;
  }
  
  // Generate TypeScript interfaces
  const interfaces = [];
  
  files.forEach(file => {
    const filePath = path.join(RESPONSES_DIR, file);
    console.log(`  ‚îú‚îÄ Processing ${file}...`);
    
    const classInfo = parseCSharpClass(filePath);
    if (classInfo) {
      const tsInterface = generateTypeScriptInterface(classInfo);
      if (tsInterface) {
        interfaces.push(tsInterface);
        console.log(`  ‚îÇ  ‚úì Generated ${classInfo.className}`);
      }
    }
  });
  
  // Write to output file
  const header = `// This file is auto-generated by scripts/generate-types.js
// DO NOT EDIT MANUALLY - Changes will be overwritten
// Generated from: FreeWaterTips.Utils/Responses/*.cs
// Last updated: ${new Date().toISOString()}

`;
  
  const outputContent = header + interfaces.join('\n');
  
  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(OUTPUT_FILE, outputContent, 'utf-8');
  
  console.log(`‚úÖ Successfully generated ${interfaces.length} TypeScript interface(s)`);
  console.log(`üìÑ Output written to: ${OUTPUT_FILE}`);
}

// Run the generator
try {
  generateAllTypes();
} catch (error) {
  console.error('‚ùå Error generating types:', error.message);
  process.exit(1);
}
